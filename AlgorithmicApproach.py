# -*- coding: utf-8 -*-
"""united2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xgt7V3OKnOJDkuUOEAYKLf3zDQ1mwozG
"""

# from google.colab import drive
# drive.mount('/content/drive')

# resize for fisrt nn
import PIL
import os
import os.path
from PIL import Image

f = r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\pic'
g = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\femur\val_images\val"
for file in os.listdir(f):
    f_img = f + "/" + file
    g_img = g + "/" + file
    img = Image.open(f_img)
    img = img.resize((128, 128))
    img.save(g_img)

# prediction of first(femur) nn and save the 128*128 result
checkpoint_filepath1 = r'E:\Project\Codes\Contour Extraction - Classic Method\4'
# Load previously saved model
from keras.models import load_model

model = load_model(checkpoint_filepath1)
import os

names = '1.png'
print(len(names))

seed = 24
batch_size = 1
n_classes = 2

from tensorflow.keras.utils import to_categorical
from sklearn.preprocessing import LabelEncoder


# Define a function to perform additional preprocessing after datagen.
# For example, scale images, convert masks to categorical, etc.
def preprocess_data(img, mask, num_class):
    # Scale images
    img = img / 255.  # This can be done in ImageDataGenerator but showing it outside as an example
    # Convert mask to one-hot
    labelencoder = LabelEncoder()
    n, h, w, c = mask.shape
    mask = mask.reshape(-1, 1)
    mask = labelencoder.fit_transform(mask)
    mask = mask.reshape(n, h, w, c)
    mask = to_categorical(mask, num_class)

    return (img, mask)


# Define the generator.
# We are not doing any rotation or zoom to make sure mask values are not interpolated.
# It is important to keep pixel values in mask as 0, 1, 2, 3, .....
from tensorflow.keras.preprocessing.image import ImageDataGenerator


def trainGenerator(train_img_path, train_mask_path, num_class):
    img_data_gen_args = dict(horizontal_flip=False,
                             vertical_flip=False,
                             fill_mode='reflect')

    image_datagen = ImageDataGenerator(**img_data_gen_args)
    mask_datagen = ImageDataGenerator(**img_data_gen_args)

    image_generator = image_datagen.flow_from_directory(
        train_img_path,
        class_mode=None,
        color_mode='grayscale',
        target_size=(128, 128),
        batch_size=batch_size,
        seed=seed)

    mask_generator = mask_datagen.flow_from_directory(
        train_mask_path,
        class_mode=None,
        color_mode='grayscale',
        target_size=(128, 128),
        batch_size=batch_size,
        seed=seed)

    train_generator = zip(image_generator, mask_generator)

    for (img, mask) in train_generator:
        img, mask = preprocess_data(img, mask, num_class)
        yield (img, mask)


test_img_path = r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\femur\val_images'
test_mask_path = r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\femur\val_masks'
test_img_gen = trainGenerator(test_img_path, test_mask_path, num_class=2)
test_image_batch, test_mask_batch = test_img_gen.__next__()

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

print('len(names):', 1)
for i in range(1):
    test_img_number = i
    print(test_image_batch.shape)
    test_img = test_image_batch[test_img_number]
    # test_img = test_image_batch[i]
    test_img_norm = test_img[:, :, 0][:, :, None]
    ground_truth = test_mask_batch[test_img_number]
    ground_truth = np.argmax(ground_truth, axis=2)
    test_img_input = np.expand_dims(test_img_norm, 0)
    prediction = (model.predict(test_img_input))
    predicted_img = np.argmax(prediction, axis=3)[0, :, :]

    # imageio.imwrite('/content/drive/MyDrive/data0/predicted/{}'.format(names[i],predicted_img), predicted_img)

    im = Image.fromarray((predicted_img * 255).astype(np.uint8))
    im.save(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\result1\1.png')

import matplotlib.pyplot as plt

# resize to original size
import PIL
import os
import os.path
from PIL import Image

f = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\result1"
g = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\result1"
for file in os.listdir(f):
    f_img = f + "/" + file
    g_img = g + "/" + file
    img = Image.open(f_img)
    img = img.resize((1627, 798))
    img.save(g_img)

# extracting coordinates
f = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\result1"
f_img = f + "\\" + file
img = PIL.Image.open(f_img)
img = np.array(img)
x1 = 10000
y1 = 10000
x2 = 0
y2 = 0
for i in range(798):
    for j in range(1627):
        if img[i, j] > 0:
            if i > y2:
                y2 = i
            if i < y1:
                y1 = i
            if j > x2:
                x2 = j
            if j < x1:
                x1 = j

print(x1, y1, x2, y2)

leftBorder = x1
rightBorder = x2
topBorder = y1
bottomBorder = y2

from PIL import Image

f = r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\pic'
f_img = f + "/" + file
im = Image.open(f_img)
im = im.crop((x1, y1, x2, y2))
g = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images\val"
g_img = g + "/" + file
im.save(g_img)
plt.subplot(131)
plt.xticks([])
plt.yticks([])
plt.imshow(test_img[:, :, 0], cmap='gray')
plt.subplot(132)
plt.xticks([])
plt.yticks([])
plt.imshow(im, cmap='jet')
# plt.show()

tool = y2 - y1
arz = x2 - x1
delta = (tool - arz) / 2
delta = int(delta)
f = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images\val"
f_img = f + "/" + file
img = PIL.Image.open(f_img)
img2 = np.array(img)
num_of_channel = np.shape(img2)[-1]
add = np.zeros((tool, delta, num_of_channel))
print(add.shape)
img2 = np.hstack((add, img2))
img2 = np.hstack((img2, add))

im = Image.fromarray((img2).astype(np.uint8))
g = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images\val"
g_img = g + "/" + file
im.save(g_img)

f = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images\val"
g = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images\val"
for file in os.listdir(f):
    f_img = f + "/" + file
    g_img = g + "/" + file
    img = Image.open(f_img)
    img = img.resize((512, 512))
    img.save(g_img)

checkpoint_filepath2 = r'E:\Project\Codes\Contour Extraction - Classic Method\bestmodel2'
# Load previously saved model
from keras.models import load_model

model = load_model(checkpoint_filepath2)
import os

names = (os.listdir(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images\val'))
print(len(names))

seed = 24
batch_size = len(names)
n_classes = 2

from tensorflow.keras.utils import to_categorical
from sklearn.preprocessing import LabelEncoder


# Define a function to perform additional preprocessing after datagen.
# For example, scale images, convert masks to categorical, etc.
def preprocess_data(img, mask, num_class):
    # Scale images
    img = img / 255.  # This can be done in ImageDataGenerator but showing it outside as an example
    # Convert mask to one-hot
    labelencoder = LabelEncoder()
    n, h, w, c = mask.shape
    mask = mask.reshape(-1, 1)
    mask = labelencoder.fit_transform(mask)
    mask = mask.reshape(n, h, w, c)
    mask = to_categorical(mask, num_class)

    return (img, mask)


# Define the generator.
# We are not doing any rotation or zoom to make sure mask values are not interpolated.
# It is important to keep pixel values in mask as 0, 1, 2, 3, .....
from tensorflow.keras.preprocessing.image import ImageDataGenerator


def trainGenerator(train_img_path, train_mask_path, num_class):
    img_data_gen_args = dict(horizontal_flip=False,
                             vertical_flip=False,
                             fill_mode='reflect')

    image_datagen = ImageDataGenerator(**img_data_gen_args)
    mask_datagen = ImageDataGenerator(**img_data_gen_args)

    image_generator = image_datagen.flow_from_directory(
        train_img_path,
        class_mode=None,
        color_mode='grayscale',
        target_size=(512, 512),
        batch_size=batch_size,
        seed=seed)

    mask_generator = mask_datagen.flow_from_directory(
        train_mask_path,
        class_mode=None,
        color_mode='grayscale',
        target_size=(512, 512),
        batch_size=batch_size,
        seed=seed)

    train_generator = zip(image_generator, mask_generator)

    for (img, mask) in train_generator:
        img, mask = preprocess_data(img, mask, num_class)
        yield (img, mask)


test_img_path = r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images'
test_mask_path = r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_masks'
test_img_gen = trainGenerator(test_img_path, test_mask_path, num_class=2)
test_image_batch, test_mask_batch = test_img_gen.__next__()

import numpy as np
from PIL import Image

for i in range(len(names)):
    test_img_number = i
    print(test_image_batch.shape)
    test_img = test_image_batch[test_img_number]
    test_img_norm = test_img[:, :, 0][:, :, None]
    ground_truth = test_mask_batch[test_img_number]
    ground_truth = np.argmax(ground_truth, axis=2)
    test_img_input = np.expand_dims(test_img_norm, 0)
    prediction = (model.predict(test_img_input))
    predicted_img = np.argmax(prediction, axis=3)[0, :, :]

    # imageio.imwrite('/content/drive/MyDrive/data0/predicted/{}'.format(names[i],predicted_img), predicted_img)

    im = Image.fromarray((predicted_img * 255).astype(np.uint8))
    im.save(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\result2\{}'.format(names[i], im))

import matplotlib.pyplot as plt
import PIL
import os
import os.path
from PIL import Image

f = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\result2"
g = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\result2"
for file in os.listdir(f):
    f_img = f + "/" + file
    g_img = g + "/" + file
    img = Image.open(f_img)
    img = img.resize((tool, tool))
    img.save(g_img)

f = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\result2"
f_img = f + "/" + file
img = PIL.Image.open(f_img)
img = np.array(img)
x11 = 10000
y11 = 10000
x22 = 0
y22 = 0
for i in range(tool):
    for j in range(tool):
        if img[i, j] > 0:
            if i > y22:
                y22 = i
            if i < y11:
                y11 = i
            if j > x22:
                x22 = j
            if j < x11:
                x11 = j

x11 = x11 - delta
x22 = x22 - delta
circleLeftBorder = x11
circleRightBorder = x22
circleTopBorder = y11
circleBottomBorder = y22
x11 = x1 + x11
x22 = x1 + x22
y11 = y1 + y11
y22 = y1 + y22

print(x11, y11, x22, y22)

from PIL import Image

f = r"E:\Project\Codes\Contour Extraction - Classic Method\testdata\pic"
f_img = f + "/" + file
im = Image.open(f_img)
im = im.crop((x11, y11, x22, y22))
plt.subplot(133)
plt.imshow(im, cmap='jet')
plt.xticks([])
plt.yticks([])
plt.show()

# deleting folders
import os
import glob

# files = glob.glob(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\pic\*')
# for f in files:
#     os.remove(f)

files = glob.glob(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\result1\*')
for f in files:
    os.remove(f)

files = glob.glob(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\result2\*')
for f in files:
    os.remove(f)

files = glob.glob(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\femur\val_images\val\*')
for f in files:
    os.remove(f)

files = glob.glob(r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\head\val_images\val\*')
for f in files:
    os.remove(f)

import numpy as np
from numpy.polynomial import Polynomial as P
import matplotlib.pyplot as plt
import cv2 as cv2
from numpy.ma.core import absolute
import skimage.io as sk
import xlsxwriter as xl


# -------------------------- Functions ------------------------------------
# -------------------------- Functions ------------------------------------
def oneOfFour(Femur, fourDots):
    '''This function gets photo and the array in which four points of each line have been saved, and 
        choses best one of this four point using an Error define in it.
        
        Arguments: photo, array
        
        returns: an array including indice of one point of each line.'''

    # To find best one among this four points...
    # In the first line:

    Error = np.zeros((1, 4))
    for point in range(4):  # for each point chosen in first line of fourIncDots (last line of the femur)
        for r in range(1, len(fourDots)):  # for each line of the femur, above the last line
            for c in range(4):  # for rach point of every line above the last line
                Error[0][point] = Error[0][point] + 0.2 * (
                            Femur[-1][fourDots[0][point]] - Femur[-1 - 10 * r][fourDots[r][c]]) ** 2 \
                                  + 0.8 * (fourDots[0][point] - fourDots[r][c]) ** 2
    oneDots = np.zeros((len(fourDots), 1))
    minError = np.where(Error == min(Error))
    oneDots[0] = fourDots[0][minError[1][0]]
    oneDots = oneDots.astype(int)

    # In rest of the lines:

    for r in range(1, len(fourDots)):
        Error = np.zeros((1, 4))

        for i in range(4):
            Error[0][i] = 0.2 * (Femur[-1 - 10 * r][fourDots[r][i]] - Femur[-1 - 10 * (r - 1)][oneDots[r - 1][0]]) ** 2 \
                          + 0.8 * (fourDots[r][i] - oneDots[r - 1][0]) ** 2

        minError = np.where(Error == min(Error))
        oneDots[r] = fourDots[r][minError[1][0]]

    # Added part:
    oneDotsHolder = oneDots
    oneDots = np.zeros((len(oneDotsHolder), 2))

    for i in range(len(oneDotsHolder)):
        oneDots[i][0] = -10 * i
        oneDots[i][1] = oneDotsHolder[i]
    oneDots[0][0] = -1
    oneDots = oneDots.astype(int)

    return oneDots


def distance(m, h, x0, y0):
    '''Gets the equation of a line and coordinates of a point and returns the distance of the point from the line.
    
    Arguments: \nm and h are the slope and y-intercept of the line; x0 and y0 are coordinates of the point.

    Returns: \ndistance
    '''
    a = m
    b = -1
    c = h

    d = np.absolute(a * x0 + b * y0 + c) / np.sqrt(a ** 2 + b ** 2)

    return d


def wasteEliminator(oneDots):
    diff = np.zeros((len(oneDots) - 1, 1))

    for i in range(len(oneDots) - 1):
        diff[i][0] = oneDots[i + 1][1] - oneDots[i][1]
        avgDiff = np.absolute(np.mean(diff))  # to find average of horizantal distance between two sequential point

    # helpPoints = np.zeros((int(rows_to_get_familiar/100),2))
    helpPoints = np.zeros((5, 2))
    cluster_length = int(len(oneDots) / 5)
    for i in range(len(helpPoints)):  # To have five mean points and pass a line through them, in order to have a datum
        helpPoints[i][0] = np.mean(oneDots[cluster_length * i:cluster_length * (i + 1), 0])
        helpPoints[i][1] = np.mean(oneDots[cluster_length * i:cluster_length * (i + 1), 1])
    helpPoints = helpPoints.astype(int)

    # best line passing through these helpPoints:   "y = mx + h"
    p = np.polyfit(helpPoints[:, 1], helpPoints[:, 0], 1)
    m = p[0]
    h = p[1]

    indexesToBeRemoved = []
    for i in range(1, len(oneDots)):
        if np.absolute(oneDots[i][1] - oneDots[i - 1][1]) > 8 * avgDiff:
            if distance(m, h, oneDots[i][1], 10 * i) > distance(m, h, oneDots[i - 1][1], 10 * i):
                oneDots[i] = False
                indexesToBeRemoved.append(i)
            else:
                oneDots[i - 1] = False
                indexesToBeRemoved.append(i - 1)

    if indexesToBeRemoved != []:
        oneDots = np.delete(oneDots, indexesToBeRemoved, axis=0)

    return oneDots


def filter0(starterPoint, filter0_length):
    # An odd number!
    filter = np.zeros((filter0_length, 2))

    filter[:, 0] = starterPoint[0][0] - 1

    for i in range(len(filter)):
        # filter[i][0] = followStart[0][0] - 1
        filter[i][1] = starterPoint[0][1] - (filter0_length - 1) / 2 + i

    filter = filter.astype(int)

    return filter


def filter0_upperArea(starterPoint, filter0_length):
    filter = np.zeros((filter0_length // 2, 2))

    filter[:, 0] = starterPoint[0][0] - 1

    for i in range(len(filter)):
        # filter[i][0] = followStart[0][0] - 1
        filter[i][1] = starterPoint[0][1] + i

    filter = filter.astype(int)

    return filter


def filterPi(starterPoint, filterPi_length):
    filter = np.zeros((filterPi_length, 2))

    filter[:, 0] = starterPoint[0][0] + 1

    for i in range(len(filter)):
        filter[i][1] = starterPoint[0][1] - (filterPi_length - 1) / 2 + i

    filter = filter.astype(int)

    return filter


def filterPiSecond(starterPoint, filterPiSecond_length):
    # Length most be an odd number!
    filter = np.zeros((filterPiSecond_length, 2))

    filter[:, 1] = starterPoint[0][1] - 1

    for i in range(len(filter)):
        filter[i][0] = starterPoint[0][0] - (filterPiSecond_length - 1) / 2 + i

    filter = filter.astype(int)

    return filter


def filter3piSecond(starterPoint, filter3piSecond_length):
    # An odd number!
    filter = np.zeros((filter3piSecond_length, 2))

    filter[:, 1] = starterPoint[0][1] + 1

    for i in range(len(filter)):
        filter[i][0] = starterPoint[0][0] - (filter3piSecond_length - 1) / 2 + i

    filter = filter.astype(int)

    return filter


def apply_filter(Femur, filter, followDots):
    diffs = np.zeros((1, len(filter) - 1))

    for i in range(len(filter) - 1):
        diffs[0][i] = np.absolute(Femur[filter[i + 1][0]][filter[i + 1][1]] - Femur[filter[i][0]][filter[i][1]])

    sortedDiffs = np.sort(diffs)
    index = np.where(diffs == sortedDiffs[0][-1])[1][0]

    if Femur[filter[index][0]][filter[index][1]] < Femur[filter[index + 1][0]][filter[index + 1][1]]:
        followDots = np.append(followDots, [filter[index]], axis=0)
        starterPoint = [filter[index]]
    else:
        followDots = np.append(followDots, [filter[index + 1]], axis=0)
        starterPoint = [filter[index + 1]]

    # # print(filter[index[0]])
    # # print('=======================')
    followDots = followDots.astype(int)
    # print(followDots[:,0])
    for i, elem in enumerate(followDots[:, 0]):
        if elem < 0:
            followDots[i, 0] += len(Femur)

    return followDots, starterPoint


def pre_apply_filter(Femur, filter):
    diffs = np.zeros((1, len(filter) - 1))

    for i in range(len(filter) - 1):
        diffs[0][i] = Femur[filter[i + 1][0]][filter[i + 1][1]] - Femur[filter[i][0]][filter[i][1]]

    sortedDiff = np.sort(diffs)
    return sortedDiff


def contourFollowing(Femur, starterPoint, filterToStartWith, endingSituation, endLine=None, endColumn=None, circle=None,
                     constantFilter=False, NumberOfStepsToGoUpAtFirst=20, tail=20, gap=20, p=None, optionalFilter=None,
                     filter0_length=9, filterPi_length=5, filterPiSecond_length=5, filter3piSecond_length=5,
                     name_of_step='Not Entered'):
    '''
    'filterToStartWith' shall be a string and you have four options for it: 'filter0', 'filterPi', 'filterPiSecond', and 'filter3PiSecond'.
    'constantFilter' could be one of these options or none of them: 'filter0', 'filterPi', 'filterPiSecond', and 'filter3PiSecond'.
    'endingSituation' should be one of these two options: 'line' or 'column' or 'SetLine' or 'circleInside' or 'circleOn' or 'circleOutside'.
    '''
    starterPoint = starterPoint.astype(int)
    starterPoint = starterPoint.reshape((1, 2))

    distanceToGoal = False

    if optionalFilter == None:
        if endingSituation == 'line':
            if np.absolute(starterPoint[0][0] - endLine) < 2:
                distanceToGoal = True
        elif endingSituation == 'column':
            if np.absolute(starterPoint[0][1] - endColumn) < 2:
                distanceToGoal = True
        elif endingSituation == 'circleInside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) <= circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOn':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) == circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOutside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) >= circle[2]:
                distanceToGoal = True

        followDots = np.empty((0, 2))

        for t in range(NumberOfStepsToGoUpAtFirst):
            # for t in range(p):
            if distanceToGoal:
                break

            if filterToStartWith == 'filter0':
                filter = filter0(starterPoint, filter0_length)
                followDots, starterPoint = apply_filter(Femur, filter, followDots)
                # print('t = ', t)           
            elif filterToStartWith == 'filterPi':
                filter = filterPi(starterPoint, filterPi_length)
                followDots, starterPoint = apply_filter(Femur, filter, followDots)
                # print('t = ', t)
            elif filterToStartWith == 'filterPiSecond':
                filter = filterPiSecond(starterPoint, filterPiSecond_length)
                followDots, starterPoint = apply_filter(Femur, filter, followDots)
                # print('t = ', t)
            elif filterToStartWith == 'filter3PiSecond':
                filter = filter3piSecond(starterPoint, filter3piSecond_length)
                followDots, starterPoint = apply_filter(Femur, filter, followDots)
                # print('t = ', t)

            if endingSituation == 'line':
                if np.absolute(followDots[-1][0] - endLine) < 2:
                    distanceToGoal = True
            elif endingSituation == 'column':
                if np.absolute(followDots[-1][1] - endColumn) < 2:
                    distanceToGoal = True
            elif endingSituation == 'circleInside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) <= circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOn':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) == circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOutside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) >= circle[
                    2]:
                    distanceToGoal = True
        # print(followDots)

        iteration = 0
        filterHistory = filterToStartWith
        while not distanceToGoal:
            # for gam in range(p):
            iteration += 1

            if constantFilter == 'filter0':
                filter = filter0(starterPoint, filter0_length)
                followDots, starterPoint = apply_filter(Femur, filter, followDots)
                filterHistory = 'filter0'

            elif constantFilter == 'filterPi':
                filter = filterPi(starterPoint, filterPi_length)
                filterHistory = 'filterPi'
                followDots, starterPoint = apply_filter(Femur, filter, followDots)

            elif constantFilter == 'filterPiSecond':
                filter = filterPiSecond(starterPoint, filterPiSecond_length)
                followDots, starterPoint = apply_filter(Femur, filter, followDots)
                filterHistory = 'filterPiSecond'

            elif constantFilter == 'filter3PiSecond':
                filter = filter3piSecond(starterPoint, filter3piSecond_length)
                followDots, starterPoint = apply_filter(Femur, filter, followDots)
                filterHistory = 'filter3PiSecond'

            else:
                # p = P.fit(followDots[-tail:-1:1,1], followDots[-tail:-1:1,0],1)
                Xbar = np.sum(followDots[-tail:-1:1, 1]) / (tail - 1)
                Ybar = np.sum(followDots[-tail:-1:1, 0]) / (tail - 1)
                m = (np.dot((followDots[-tail:-1:1, 1] - Xbar), (followDots[-tail:-1:1, 0] - Ybar))) / (
                            np.sum(followDots[-tail:-1:1, 1] - Xbar) ** 2)
                m = -m
                print('\n-------- ', iteration)
                print(m)

                if (m <= np.tan(3 * np.pi / 4 - gap / 2) or m >= np.tan(np.pi / 4 + gap / 2)) and (
                        followDots[-1][0] < followDots[-tail][0]):
                    filter = filter0(starterPoint, filter0_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filter0'
                    print('filter0')

                elif (m <= np.tan(7 * np.pi / 4 - gap / 2) or m >= np.tan(5 * np.pi / 4 + gap / 2)) and (
                        followDots[-1][0] > followDots[-tail][0]):
                    filter = filterPi(starterPoint, filterPi_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filterPiSecond'
                    print('filterPi')

                elif (np.tan(-np.pi / 4 + gap / 2) <= m <= np.tan(np.pi / 4 - gap / 2)) and (
                        followDots[-1][1] > followDots[-tail][1]):
                    filter = filter3piSecond(starterPoint, filter3piSecond_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filter3PiSecond'
                    print('3PiSecond')

                elif (np.tan(3 * np.pi / 4 + gap / 2) <= m <= np.tan(5 * np.pi / 4 - gap / 2)) and (
                        followDots[-1][1] < followDots[-tail][1]):
                    filter = filterPiSecond(starterPoint, filterPiSecond_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filterPiSecond'
                    print('PiSecond')

                elif (np.tan(np.pi / 4 - gap / 2) < m < np.tan(np.pi / 4 + gap / 2)) and (
                        followDots[-1][1] > followDots[-tail][1]):
                    # Two candidates are filter0 and filter3PiSecond. Winner is the one who detects higher value of diff among the pixels of it!
                    filter = filter3piSecond(starterPoint, filter3piSecond_length)
                    sortedDiffs3PiSecond = pre_apply_filter(Femur, filter)

                    filter = filter0(starterPoint, filter0_length)
                    sortedDiffs0 = pre_apply_filter(Femur, filter)

                    # Choosing winner!
                    if sortedDiffs0[0][-1] > sortedDiffs3PiSecond[0][-1]:
                        filter = filter0(starterPoint, filter0_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filter0'
                        print('evaluated filter0')

                    elif sortedDiffs3PiSecond[0][-1] > sortedDiffs0[0][-1]:
                        filter = filter3piSecond(starterPoint, filter3piSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filter3PiSecond'
                        print('evaluated filter3PiSecond')

                    else:
                        filter = filter0(starterPoint, filter0_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filter0'
                        print('evaluated filter0')

                elif (np.tan(3 * np.pi / 4 - gap / 2) < m < np.tan(3 * np.pi / 4 + gap / 2)) and (
                        followDots[-1][1] < followDots[-tail][1]):
                    # Two candidates are filter0 and filterPiSecond. Winner is the one who detects higher value of diff among the pixels of it!
                    filter = filter0(starterPoint, filter0_length)
                    sortedDiffs0 = pre_apply_filter(Femur, filter)

                    filter = filterPiSecond(starterPoint, filterPiSecond_length)
                    sortedDiffsPiSecond = pre_apply_filter(Femur, filter)

                    # Choosing winner!
                    if sortedDiffs0[0][-1] > sortedDiffsPiSecond[0][-1]:
                        filter = filter0(starterPoint, filter0_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filter0'
                        print('evaluated filter0')

                    elif sortedDiffsPiSecond[0][-1] > sortedDiffs0[0][-1]:
                        filter = filterPiSecond(starterPoint, filterPiSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filterPiSecond'
                        print('evaluated filterPiSecond')

                    else:
                        filter = filter0(starterPoint, filter0_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filter0'
                        print('evaluated filter0')

                elif (np.tan(5 * np.pi / 4 - gap / 2) < m < np.tan(5 * np.pi / 4 + gap / 2)) and (
                        followDots[-1][0] > followDots[-tail][0]):
                    # Two candidates are filterPiSecond and filterPi. Winner is the one who detects higher value of diff among the pixels of it!
                    filter = filterPiSecond(starterPoint, filterPiSecond_length)
                    sortedDiffsPiSecond = pre_apply_filter(Femur, filter)

                    filter = filterPi(followDots, filterPi_length)
                    sortedDiffsPi = pre_apply_filter(Femur, filter)

                    # Choosing winner!
                    if sortedDiffsPiSecond[0][-1] > sortedDiffsPi[0][-1]:
                        filter = filterPiSecond(starterPoint, filterPiSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filterPiSecond'
                        print('evaluated filterPiSecond')

                    elif sortedDiffsPi[0][-1] > sortedDiffsPiSecond[0][-1]:
                        filter = filterPi(starterPoint, filterPi_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filterPi'
                        print('evaluated filterPi')

                    else:
                        filter = filterPiSecond(starterPoint, filterPiSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filterPiSecond'
                        print('evaluated filterPiSecond')

                elif (np.tan(7 * np.pi / 4 - gap / 2) < m < np.tan(7 * np.pi / 4 + gap / 2)) and (
                        followDots[-1][1] > followDots[-tail][1]):
                    # Two candidates are filterPi and filter3PiSecond. Winner is the one who detects higher value of diff among the pixels of it!
                    filter = filterPi(starterPoint, filterPi_length)
                    sortedDiffsPi = pre_apply_filter(Femur, filter)

                    filter = filter3piSecond(starterPoint, filter3piSecond_length)
                    sortedDiffs3PiSecond = pre_apply_filter(Femur, filter)

                    # Choosing winner!
                    if sortedDiffsPi[0][-1] > sortedDiffs3PiSecond[0][-1]:
                        filter = filterPi(starterPoint, filterPi_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filterPi'
                        print('evaluated filterPi')

                    elif sortedDiffs3PiSecond[0][-1] > sortedDiffsPi[0][-1]:
                        filter = filter3piSecond(starterPoint, filter3piSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filter3PiSecond'
                        print('evaluated filter3PiSecond')

                    else:
                        filter = filter3piSecond(starterPoint, filter3piSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                        filterHistory = 'filter3PiSecond'
                        print('evaluated filter3PiSecond')

                else:
                    if filterHistory == 'filter0':
                        filter = filter0(starterPoint, filter0_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    elif filterHistory == 'filterPi':
                        filter = filterPi(starterPoint, filterPi_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    elif filterHistory == 'filterPiSecond':
                        filter = filterPiSecond(starterPoint, filterPiSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    elif filterHistory == 'filter3PiSecond':
                        filter = filter3piSecond(starterPoint, filter3piSecond_length)
                        followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    print(filterHistory, '. no other choice.')
            print(name_of_step)

            if endingSituation == 'line':
                if np.absolute(followDots[-1][0] - endLine) < 2:
                    distanceToGoal = True
            elif endingSituation == 'column':
                if np.absolute(followDots[-1][1] - endColumn) < 2:
                    distanceToGoal = True
            elif endingSituation == 'circleInside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) <= circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOn':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) == circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOutside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) >= circle[
                    2]:
                    distanceToGoal = True

    elif optionalFilter == 'upperArea':
        if endingSituation == 'line':
            if np.absolute(starterPoint[0][0] - endLine) < 2:
                distanceToGoal = True
        elif endingSituation == 'column':
            if np.absolute(starterPoint[0][1] - endColumn) < 2:
                distanceToGoal = True
        elif endingSituation == 'circleInside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) <= circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOn':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) == circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOutside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) >= circle[2]:
                distanceToGoal = True

        followDots = np.empty((0, 2))

        filterChoosing = True
        while not distanceToGoal:

            # starterPoint[0][1] += (filter0_length//2 + 1)

            # for i in range(70):
            if filterChoosing:
                # Two candidates are filter0_upperArea and filter3PiSecond. Winner is the one who detects higher value of diff among the pixels of it!
                filter = filter3piSecond(starterPoint, filter3piSecond_length)
                sortedDiffs3PiSecond = pre_apply_filter(Femur, filter)

                filter = filter0_upperArea(starterPoint, filter0_length)
                sortedDiffs0 = pre_apply_filter(Femur, filter)

                # Choosing winner!
                if sortedDiffs0[0][-1] > sortedDiffs3PiSecond[0][-1]:
                    filter = filter0_upperArea(starterPoint, filter0_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filter0'
                    print('evaluated filter0')
                    # T = 3
                    # filterChoosing = False
                elif sortedDiffs3PiSecond[0][-1] > sortedDiffs0[0][-1]:
                    filter = filter3piSecond(starterPoint, filter3piSecond_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filter3PiSecond'
                    print('evaluated filter3PiSecond')
                    # T = 3
                    # filterChoosing = False
                else:
                    filter = filter0_upperArea(starterPoint, filter0_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filter0'
                    print('evaluated filter0')
                    # T = 3
                    # filterChoosing = False
            # else:
            #     T -= 1
            #     if T <= 0:
            #         filterChoosing = True

            #     if filterHistory == 'filter0':
            #         filter = filter0(starterPoint, filter0_length)
            #         followDots, starterPoint = apply_filter(Femur, filter, followDots)
            #         print('evaluated filter0')
            #     elif filterHistory == 'filter3PiSecond':
            #         filter = filter3piSecond(starterPoint, filter3piSecond_length)
            #         followDots, starterPoint = apply_filter(Femur, filter, followDots)
            #         print('evaluated filter3PiSecond')

            if endingSituation == 'line':
                if np.absolute(followDots[-1][0] - endLine) < 2:
                    distanceToGoal = True
            elif endingSituation == 'column':
                if np.absolute(followDots[-1][1] - endColumn) < 2:
                    distanceToGoal = True
            elif endingSituation == 'circleInside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) <= circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOn':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) == circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOutside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) >= circle[
                    2]:
                    distanceToGoal = True
            print(name_of_step)

    elif optionalFilter == 'lowerArea':
        if endingSituation == 'line':
            if np.absolute(starterPoint[0][0] - endLine) < 2:
                distanceToGoal = True
        elif endingSituation == 'column':
            if np.absolute(starterPoint[0][1] - endColumn) < 2:
                distanceToGoal = True
        elif endingSituation == 'circleInside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) <= circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOn':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) == circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOutside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) >= circle[2]:
                distanceToGoal = True

        followDots = np.empty((0, 2))

        filterChoosing = True
        while not distanceToGoal:
            if filterChoosing:
                # Two candidates are filterPiSecond and filterPi. Winner is the one who detects higher value of diff among the pixels of it!
                filter = filterPiSecond(starterPoint, filterPiSecond_length)
                sortedDiffsPiSecond = pre_apply_filter(Femur, filter)

                filter = filterPi(starterPoint, filterPi_length)
                sortedDiffsPi = pre_apply_filter(Femur, filter)

                # Choosing winner!
                if sortedDiffsPiSecond[0][-1] > sortedDiffsPi[0][-1]:
                    filter = filterPiSecond(starterPoint, filterPiSecond_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filterPiSecond'
                    print('evaluated filterPiSecond')
                    # T = 3
                    # filterChoosing = False
                elif sortedDiffsPi[0][-1] > sortedDiffsPiSecond[0][-1]:
                    filter = filterPi(starterPoint, filterPi_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filterPi'
                    print('evaluated filterPi')
                    # T = 3
                    # filterChoosing = False
                else:
                    filter = filterPiSecond(starterPoint, filterPiSecond_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filterPiSecond'
                    print('evaluated filterPiSecond')
                    # T = 3  
                    # filterChoosing = False
            # else:
            #     T-= 1
            #     if T <= 0:
            #         filterChoosing = True

            #     if filterHistory == 'filterPiSecond':
            #         filter = filterPiSecond(starterPoint, filterPiSecond_length)
            #         followDots, starterPoint = apply_filter(Femur, filter, followDots)
            #         print('evaluated filterPiSecond')        
            #     elif filterHistory == 'filterPi':
            #         filter = filterPi(starterPoint, filterPi_length)
            #         followDots, starterPoint = apply_filter(Femur, filter, followDots)
            #         print('evaluated filterPi')

            if endingSituation == 'line':
                if np.absolute(followDots[-1][0] - endLine) < 2:
                    distanceToGoal = True
            elif endingSituation == 'column':
                if np.absolute(followDots[-1][1] - endColumn) < 2:
                    distanceToGoal = True
            elif endingSituation == 'circleInside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) <= circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOn':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) == circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOutside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) >= circle[
                    2]:
                    distanceToGoal = True
            print(name_of_step)

    elif optionalFilter == 'lowerArea_DownToUp':
        if endingSituation == 'line':
            if np.absolute(starterPoint[0][0] - endLine) < 2:
                distanceToGoal = True
        elif endingSituation == 'column':
            if np.absolute(starterPoint[0][1] - endColumn) < 2:
                distanceToGoal = True
        elif endingSituation == 'circleInside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) <= circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOn':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) == circle[2]:
                distanceToGoal = True
        elif endingSituation == 'circleOutside':
            if int(np.sqrt((circle[0] - starterPoint[0][0]) ** 2 + (circle[1] - starterPoint[0][1]) ** 2)) >= circle[2]:
                distanceToGoal = True

        followDots = np.empty((0, 2))

        filterChoosing = True
        while not distanceToGoal:
            if filterChoosing:
                # Three candidates are filter0 and filterPiSecond and filter3PiSecond. Winner is the one who detects higher value of diff among the pixels of it!
                filter = filter0(starterPoint, filter0_length)
                sortedDiffs0 = pre_apply_filter(Femur, filter)

                filter = filterPi(starterPoint, filterPi_length)
                sortedDiffsPi = pre_apply_filter(Femur, filter)

                # Choosing winner!
                if sortedDiffs0[0][-1] > sortedDiffsPi[0][-1]:  # and sortedDiffs0[0][-1] > sortedDiffs3PiSecond[0][-1]:
                    filter = filter0(starterPoint, filter0_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filter0'
                    print('evaluated filter0')
                    # T = 2
                    # filterChoosing = False
                elif sortedDiffsPi[0][-1] > sortedDiffs0[0][
                    -1]:  # and sortedDiffsPi[0][-1] > sortedDiffs3PiSecond[0][-1]:
                    filter = filterPi(starterPoint, filterPi_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filterPi'
                    print('evaluated filterPi')
                    # T = 2
                    # filterChoosing = False
                else:
                    filter = filter0(starterPoint, filter0_length)
                    followDots, starterPoint = apply_filter(Femur, filter, followDots)
                    filterHistory = 'filter0'
                    print('evaluated filter0')
                    # T = 2
                    # filterChoosing = False
            # else:
            #     T-= 1
            #     if T <= 0:
            #         filterChoosing = True

            #     if filterHistory == 'filterPiSecond':
            #         filter = filterPiSecond(starterPoint, filterPiSecond_length)
            #         followDots, starterPoint = apply_filter(Femur, filter, followDots)
            #         print('evaluated filterPiSecond')        
            #     elif filterHistory == 'filterPi':
            #         filter = filterPi(starterPoint, filterPi_length)
            #         followDots, starterPoint = apply_filter(Femur, filter, followDots)
            #         print('evaluated filterPi')

            if endingSituation == 'line':
                if np.absolute(followDots[-1][0] - endLine) < 2:
                    distanceToGoal = True
            elif endingSituation == 'column':
                if np.absolute(followDots[-1][1] - endColumn) < 2:
                    distanceToGoal = True
            elif endingSituation == 'circleInside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) <= circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOn':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) == circle[
                    2]:
                    distanceToGoal = True
            elif endingSituation == 'circleOutside':
                if int(np.sqrt((circle[0] - followDots[-1][0]) ** 2 + (circle[1] - followDots[-1][1]) ** 2)) >= circle[
                    2]:
                    distanceToGoal = True
            print(name_of_step)

    return followDots


# --------------------- Data Initialization -------------------------------
print('topBorder: ', topBorder)
print('bottomBorder: ', bottomBorder)
print('leftBorder: ', leftBorder)
print('rightBorder: ', rightBorder)

print('circleTopBorder: ', circleTopBorder)
print('circleBottomBorder: ', circleBottomBorder)
print('circleLeftBorder: ', circleLeftBorder)
print('circleRightBorder: ', circleRightBorder)

path = r'E:\Project\Codes\Contour Extraction - Classic Method\testdata\pic\1.png'
photo = sk.imread(path, as_gray=True)

Femur = photo[topBorder:bottomBorder, leftBorder:rightBorder]
# Femur = Femur[:,:,0:3]

k = np.ones((3, 3))
Femur_dialated = cv2.dilate(Femur, k, iterations=2)
Femur_eroded = cv2.erode(Femur, k, iterations=2)

PhotoHolder = sk.imread(path)
PhotoHolder = PhotoHolder[:, :, 0:3]
FemurHolder = PhotoHolder[topBorder:bottomBorder, leftBorder:rightBorder]

for i in range(len(FemurHolder[0][:]), 0, -1):
    column = FemurHolder[:, i - 1]
    if np.count_nonzero(column) > 0:
        FemurHolder = FemurHolder[:, 0:i - 6]
        newRightBorder = i
        break

FemurHolder1 = FemurHolder
FemurHolder2 = FemurHolder
FemurHolder3 = FemurHolder
FemurHolder4 = FemurHolder
FemurHolder5 = FemurHolder
FemurHolder6 = FemurHolder
FemurHolder7 = FemurHolder
FemurHolder8 = FemurHolder
FemurHolder9 = FemurHolder

Femur = Femur[:, 0:newRightBorder - 6]
plt.imshow(Femur)
plt.show()

circleTwoThirdLine = circleTopBorder + (int(circleBottomBorder - circleTopBorder) / 3) * 2
circleHalfLine = circleTopBorder + ((circleBottomBorder - circleTopBorder) // 2)

circleArea = Femur[circleTopBorder:circleBottomBorder, circleLeftBorder:circleRightBorder]
circleHolder = FemurHolder[circleTopBorder:circleBottomBorder, circleLeftBorder:circleRightBorder]

# =========================================================================
# -------------------------- Main Code ------------------------------------
# =========================================================================

# -------------------------- To warm up... ------------------------------------
rows_to_get_familiar = 100

fourIncDots = np.zeros(
    (int(rows_to_get_familiar / 10), 4))  # contains indices of the consideringemu pixels. Inc: Increasing
fourIncValues = np.zeros((int(rows_to_get_familiar / 10), 4))  # contains brightness of the considering pixels

fourDecDots = np.zeros(
    (int(rows_to_get_familiar / 10), 4))  # contains indices of the considering pixels. Dec: Decreasing
fourDecValues = np.zeros((int(rows_to_get_familiar / 10), 4))  # contains brightness of the considering pixels

t = -1

for i in range(0, rows_to_get_familiar, 10):

    line = [Femur[-1 - i]]
    diffs = np.zeros((1, len(line[0]) - 1))

    for i1 in range(len(line[0]) - 1):
        diffs[0][i1] = line[0][i1 + 1] - line[0][i1]

    sortedDiffs = np.sort(diffs)
    t += 1
    fourIncValues[t] = sortedDiffs[0][-1:-5:-1]
    fourDecValues[t] = sortedDiffs[0][0:4]

    for c in range(4):
        indice = np.where(diffs == sortedDiffs[0][-1 - c])
        fourIncDots[t][c] = indice[1][
            0]  # Therfore "first" line of fourIncDots includes considering dots from "last" line of the Femur photo

        indice = np.where(diffs == sortedDiffs[0][0 + c])
        fourDecDots[t][c] = indice[1][
            0]  # Therfore "first" line of fourIncDots includes considering dots from "last" line of the Femur photo

fourIncDots = fourIncDots.astype(int)
fourDecDots = fourDecDots.astype(int)

oneIncDots = oneOfFour(Femur, fourIncDots)
oneDecDots = oneOfFour(Femur, fourDecDots)

oneIncDots = wasteEliminator(oneIncDots)
oneDecDots = wasteEliminator(oneDecDots)

xBar = np.sum(oneIncDots[:, 1]) / len(oneIncDots)
yBar = np.sum(oneIncDots[:, 0]) / len(oneIncDots)
num = 0
den = 0
for i in range(len(oneIncDots)):
    num += (oneIncDots[i][1] - xBar) * (oneIncDots[i][0] - yBar)
    den += (oneIncDots[i][1] - xBar) ** 2
m = -num / den
angle = np.arctan(m)
angle = np.degrees(angle)
angle = 90 - angle
center = ((circleRightBorder - circleLeftBorder) // 2, (circleBottomBorder - circleTopBorder) // 2)

print('m is : ', m)
print('angle is : ', angle)
plt.imshow(Femur)
plt.show()
# -------------------------- Detecting Circle ------------------------------------
c_photo = sk.imread(path)

c_Femur = c_photo[topBorder:bottomBorder, leftBorder:rightBorder]
c_PhotoHolder = sk.imread(path)
c_FemurHolder = c_PhotoHolder[topBorder:bottomBorder, leftBorder:rightBorder]

circleAreaHolder = c_FemurHolder[circleTopBorder:circleBottomBorder, circleLeftBorder:circleRightBorder]
circleArea = c_Femur[circleTopBorder:circleBottomBorder, circleLeftBorder:circleRightBorder]
# plt.imshow(circleArea)
# plt.show()
circleArea = cv2.cvtColor(circleArea, cv2.COLOR_BGR2GRAY)

minRadius = circleArea.shape[1] // 3
maxRadius = 2 * circleArea.shape[1] // 3

circles = cv2.HoughCircles(circleArea, cv2.HOUGH_GRADIENT, 2, 5,
                           param1=70,
                           param2=35,
                           minRadius=minRadius,
                           maxRadius=maxRadius)

circles = np.uint16(np.around(circles))
i = 0
center_col = circles[0][i][0] + circleLeftBorder
center_row = circles[0][i][1] + circleTopBorder
radius = circles[0][i][2]

circle = [center_row, center_col, radius]
# cv2.circle(circleAreaHolder,(center_col,center_row),radius,(0,0,255))

circleDots = np.empty((1, 2))
for row in range(int(0.7 * circleTopBorder), int(1.5 * circleBottomBorder)):
    for col in range(int(0.7 * circleLeftBorder), int(1.5 * circleRightBorder)):
        if int(np.sqrt((center_col - col) ** 2 + (center_row - row) ** 2)) == radius:
            circleDots = np.append(circleDots, [[row, col]], axis=0)
            c_FemurHolder[row][col] = 255
circleDots = circleDots.astype(int)

# -------------------------- Cropping first part of upper edge area ------------------------------------
k = np.ones((3, 3))
Femur_dilation = cv2.dilate(Femur, k, iterations=2)

upperAreaWidth = 20
limiterExtent = 20
upperArea = Femur_dialated[circleTopBorder + limiterExtent:circleBottomBorder - limiterExtent,
            center_col + radius:center_col + radius + upperAreaWidth]
# upperArea = Femur_dialated[center_row-20:center_row+20, center_col+radius:center_col+radius+upperAreaWidth]
plt.imshow(upperArea)
plt.show()

upperOneDots = np.zeros((upperAreaWidth, 2))

for column in range(upperAreaWidth):
    diffs = np.zeros((1, len(upperArea) - 1))

    for dot in range(len(upperArea) - 1):
        diffs[0][dot] = upperArea[dot + 1][column] - upperArea[dot][column]

    sortedDiffs = np.sort(diffs)
    indice = np.where(diffs == sortedDiffs[0][-1])
    # upperOneDots[column] = [indice[1][0]+circleTopBorder+limiterExtent+1, column+circleRightBorder+1]
    upperOneDots[column] = [indice[1][0] + circleTopBorder + limiterExtent + 1, column + center_col + radius + 1]

# # Concatenate0:
upperOneDots = upperOneDots.astype(int)

# -------------------------- Contour Following ------------------------------------
starterPoint = oneIncDots[-1]
# concatenate1:
followIncDots = contourFollowing(Femur, starterPoint, 'filter0', 'line', endLine=center_row + radius,
                                 constantFilter='filter0', filter0_length=7, name_of_step='followIncDots')

# concatenate2:
starterPoint = followIncDots[-1]
print('starterPoint Here is: ', starterPoint)
followIncDots_complete = contourFollowing(Femur, starterPoint, 'filter0', 'circleInside',
                                          circle=[center_row, center_col, radius], constantFilter='filter0',
                                          name_of_step='name_of_step')

starterPoint = followIncDots[-1]
# followIncDots_UpToDown = contourFollowing(Femur_dialated, starterPoint, 'filterPi', 'line', endLine=followIncDots[0][0], constantFilter='filterPi', optionalFilter='lowerArea', filter0_length=7, filterPi_length=7, name_of_step='followIncDots_UpToDown')
# followIncDots_UpToDown[:,1] += 2


# concatenate3:
starterPoint = oneDecDots[-1]
followDecDots = contourFollowing(Femur_dialated, starterPoint, 'filter0', 'line', endLine=circleHalfLine + 10,
                                 filter0_length=11, name_of_step='followDecDots')

Up_NumberOfStepsToGoAtFirst = followDecDots[0][1] - upperOneDots[-1][1]

starterPoint = upperOneDots[-1]
upEndLine = oneDecDots[-1][0]
UpEndColumn = oneDecDots[-1][1]

# concatenate4:
upperFollowDots = contourFollowing(Femur_dialated, starterPoint, 'filter3PiSecond', 'column',
                                   endColumn=followDecDots[-1][1], endLine=followDecDots[-1][0],
                                   filter3piSecond_length=7, filter0_length=7,
                                   NumberOfStepsToGoUpAtFirst=Up_NumberOfStepsToGoAtFirst, tail=5,
                                   constantFilter='filter3PiSecond', optionalFilter='upperArea',
                                   name_of_step='upperFollowDots')
print('Up_NumberOfStepsTpGoAtFirst = ', Up_NumberOfStepsToGoAtFirst)
# print(upperFollowDots)

toBeDeleted = []
## Deleting FollowDecDots waste points
for i in range(len(followDecDots)):
    if followDecDots[i][0] < upperFollowDots[-1][0]:
        toBeDeleted.append(i)
followDecDots = np.delete(followDecDots, toBeDeleted, axis=0)

# concatenate5:
starterPoint = followDecDots[-1]
followDecDots_complete = contourFollowing(Femur_dialated, starterPoint, 'filter0', 'line',
                                          endLine=np.max(upperFollowDots[-20:-1, 0]), constantFilter='filter0',
                                          name_of_step='followDecDots_complete')

# starterPoint = followDecDots_complete[-1]
# upperFollowDots = contourFollowing(Femur_dialated, starterPoint, 'filterPiSecond', 'line', endLine=upperOneDots[-1][1], name_of_step = 'upperFollowDots', constantFilter='')

toBeDeleted = []
## Deleting upperFollowDots waste points
if np.any(followDecDots_complete):
    for i in range(len(upperFollowDots)):
        if upperFollowDots[i][1] > followDecDots_complete[-1][1]:
            toBeDeleted.append(i)
    upperFollowDots = np.delete(upperFollowDots, toBeDeleted, axis=0)

# Some Shifting here:
followDecDots[:, 1] -= 2  # Leftward
followDecDots_complete[:, 1] -= 2  # Leftward
upperOneDots[:, 0] += 2  # Downward
upperFollowDots[:, 0] += 2  # Downward

# -------------------------- Second phase of Deleting circle points ------------------------------------
starterPoint = np.zeros((1, 2))

starterPoint[0][0] = upperOneDots[0][0] - 3
starterPoint[0][1] = upperOneDots[0][1] - 3

# concatenate6:
follow_for_deleting_up = contourFollowing(Femur_dialated, starterPoint, 'filter0', 'circleOutside',
                                          circle=[center_row, center_col, radius], filter0_length=5,
                                          NumberOfStepsToGoUpAtFirst=Up_NumberOfStepsToGoAtFirst, tail=5,
                                          constantFilter='filter0', name_of_step='follow_for_deleting_up')
# print('follow_for_deleting_up = ', follow_for_deleting_up)
follow_for_deleting_up[:, 1] -= 2

if np.any(followIncDots_complete):
    starterPoint[0][0] = followIncDots_complete[-1][0] - 3
    starterPoint[0][1] = followIncDots_complete[-1][1] - 3
else:
    starterPoint[0][0] = followIncDots[-1][0] - 3
    starterPoint[0][1] = followIncDots[-1][1] - 3

# concatenate7:
follow_for_deleting_left = contourFollowing(Femur_dialated, starterPoint, 'filterPiSecond', 'circleOutside',
                                            circle=[center_row, center_col, radius], filterPiSecond_length=5,
                                            filter0_length=9,
                                            NumberOfStepsToGoUpAtFirst=5, tail=5, constantFilter='filterPiSecond',
                                            name_of_step='follow_for_deleting_left')
# print('follow_for_deleting_left = ', follow_for_deleting_left)
follow_for_deleting_left[:, 0] -= 2

if np.any(follow_for_deleting_up):
    up = follow_for_deleting_up[-1]
    down = follow_for_deleting_up[0]

    toBeDeleted = []

    for point in range(len(circleDots)):
        if circleDots[point][0] <= down[0] and circleDots[point][0] >= up[0] and (
                circleDots[point][1] >= up[1] or circleDots[point][1] >= down[1]):
            toBeDeleted.append(point)
    toBeDeleted = np.delete(toBeDeleted, 0)
    for index, elem in enumerate(toBeDeleted):
        toBeDeleted[index] = int(toBeDeleted[index])
    circleDots = np.delete(circleDots, toBeDeleted, axis=0)
    circleDots = np.delete(circleDots, 0, axis=0)

if np.any(follow_for_deleting_left):
    right = follow_for_deleting_left[0]
    left = follow_for_deleting_left[-1]

    toBeDeleted = []

    for point in range(len(circleDots)):
        if circleDots[point][1] <= right[1] and circleDots[point][1] >= left[1] and (
                circleDots[point][0] >= left[0] or circleDots[point][0] >= right[0]):
            toBeDeleted.append(point)
    toBeDeleted = np.delete(toBeDeleted, 0)
    for index, elem in enumerate(toBeDeleted):
        toBeDeleted[index] = int(toBeDeleted[index])
    circleDots = np.delete(circleDots, toBeDeleted, axis=0)
    circleDots = np.delete(circleDots, 0, axis=0)

# -------------------------- Deleting 4th quarter of the circle ------------------------------------
if np.any(follow_for_deleting_left):
    down = follow_for_deleting_left[-1]
else:
    down = followIncDots[-1]

if np.any(follow_for_deleting_up):
    right = follow_for_deleting_up[-1]
else:
    right = upperOneDots[0]

toBeDeleted = []

for point in range(len(circleDots)):
    if circleDots[point][0] >= right[0] and circleDots[point][1] >= down[1]:
        toBeDeleted.append(point)
toBeDeleted = np.delete(toBeDeleted, 0)
for index, elem in enumerate(toBeDeleted):
    toBeDeleted[index] = int(toBeDeleted[index])
circleDots = np.delete(circleDots, toBeDeleted, axis=0)
circleDots = np.delete(circleDots, 0, axis=0)
# print(circleDots)


# concatenate8:
# circleDots!

# --------------------------------------------------------------

# concatenate9:
starterPoint = oneIncDots[-1]
shaftEnd1 = contourFollowing(Femur, starterPoint, 'filterPi', 'line', endLine=1, constantFilter='filterPi',
                             name_of_step='shaftEnd1')

# concatenate10:
starterPoint = oneDecDots[-1]
shaftEnd2 = contourFollowing(Femur, starterPoint, 'filterPi', 'line', endLine=1, constantFilter='filterPi',
                             name_of_step='shaftEnd2')

# -------------------------- Shift Points which are required to be shifted ------------------------------------

# -------------------------- Concatenation ------------------------------------
firstPoint = [upperOneDots[0]]
# contour = np.concatenate((upperOneDots, followIncDots, followIncDots_complete, followDecDots, followDecDots_complete, upperFollowDots, follow_for_deleting_up, follow_for_deleting_left, circleDots, shaftEnd1, shaftEnd2), axis=0)
contour = np.concatenate((upperOneDots, followIncDots, followIncDots_complete, followDecDots, followDecDots_complete,
                          upperFollowDots, follow_for_deleting_up, follow_for_deleting_left, circleDots, shaftEnd1,
                          shaftEnd2), axis=0)
contour = contour.astype(int)

toBeDeleted = []
for i in range(len(contour)):
    if contour[i][0] == 0 or contour[i][0] == -1:
        toBeDeleted.append(i)
for index, elem in enumerate(toBeDeleted):
    toBeDeleted[index] = int(toBeDeleted[index])
contour = np.delete(contour, toBeDeleted, axis=0)

# workbook = xl.Workbook('contour.xlsx')
# worksheet = workbook.add_worksheet()
# row = 0
# col = 0

# for y, x in (contour):
#     worksheet.write(row, col,     y)
#     worksheet.write(row, col + 1, x)
#     row += 1
# workbook.close()

print((contour))

# -------------------------- Showing Results ------------------------------------
for i1 in range(len(contour)):
    FemurHolder[contour[i1][0]][contour[i1][1]] = [255, 225, 255]
plt.imshow(FemurHolder)
plt.show()
